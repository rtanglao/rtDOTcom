I"…<p><a href="http://rolandtanglao.com/2020/07/29/p1-blogthis-checkvist-list-links-to-blog/">Discovered</a>: Sep 24, 2025 08:45 (UTC)<a href="https://codemanship.wordpress.com/2025/09/24/tdd-under-the-microscope-1-usage-driven-design/">ME:: tl;dr-ing: When we write the code to pass the test, it must be failing;  Jason Gorman:: Test Driven Development Under The Microscope #1 â€“ Usage-Driven Design</a></p>

<h2 id="quote">QUOTE</h2>

<ul>
  <li>Read the whole thing: <a href="https://codemanship.wordpress.com/2025/09/24/tdd-under-the-microscope-1-usage-driven-design/">Jason Gorman:: TDD Under The Microscope #1 â€“ Usage-Driven Design â€“ Codemanshipâ€™s Blog</a></li>
</ul>

<blockquote>
  <p>A more flexible and robust way to describe workflow is to imply ordering of events declaratively*. Instead of â€œBoil the kettle, then pour the water into the teapotâ€, we might say â€œWhen the water is poured into the teapot, it must be at near boilingâ€. Now all of our edge cases work. We could have boiled it in a pan. We could have boiled it in a microwave. We could have watched the squirrel and then boiled the kettle again. Workflow is implied: the water has been boiled, but we leave ourselves many more routes to pouring it in the teapot.</p>
</blockquote>

<blockquote>
  <p>A similar approach can be taken with workflows like TDD; instead of â€œRun the test to see it fail, then write the simplest code to pass itâ€, we could say â€œWhen we write the code to pass the test, it must be failingâ€. Itâ€™s a subtle but important distinction, and one which Iâ€™ve realised Iâ€™ve been using for a long time when I observe developers working.</p>
</blockquote>
:ET